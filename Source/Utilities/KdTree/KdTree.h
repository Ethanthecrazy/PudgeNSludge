//////////////////////////////////////////////////////////////////////////////////////
// Filename:	KdTree.h
// Author:		Josh Fields
// Date:		5/24/12
// Purpose:		This class holds all the information for building and maintaining a KdTree
//////////////////////////////////////////////////////////////////////////////////////
#ifndef KDTREE_H
#define KDTREE_H


#include <list>
#include <vector>
#include "../CollisionLib/CollisionShapes.h"

class IBaseObject;
class CObjectManager;

class CTreeNode;
class CInternalNode;
class CLeafNode;
class CSceneObject;
struct tTraverseData;

enum emPassedFlags { PSFLAG_SPHERE, PSFLAG_CAPSULE, PSFLAG_POINT, PSFLAG_LINE, PSFLAG_FRUSTUM, PSFLAG_AABB, PSFLAG_BOX };
enum emReturnFlags { RFLAG_SPHERE, RFLAG_CAPSULE, RFLAG_AABB, RFLAG_BOX};

class CKdTree
{
private:
	CObjectManager* ObjManager;
	CTreeNode* m_pTreeRoot;
	AABB m_abSceneBounds;
	std::vector < CSceneObject* > m_vObjects;
	std::list < CLeafNode* > m_lsLeafs;
	unsigned short m_usObjIndex;
	

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// BuildTree():	Takes in a const AABB reference (_abBounds). This function starts building the Kd Tree.
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void BuildTree (const AABB& _abBounds);

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Build():	Takes in a CKdTree pointer and a CLeafNode pointer (_pTree, _pLeaf). This function will build the
	//			Kd Tree based on the scene bounds, this function will try to construct each leaf based on the size
	//			of the largest object (or any size we decided). All leafs created are leafs that fit within the scene bounds.
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void Build ( CKdTree* pTree, CLeafNode* pLeaf );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// UpdateObject():	Takes in a SceneObject pointer (_pObject). This function updates the object by removing it from the
	//					Kd Tree and then placing it back in the Kd Tree.  This function is not cheap and should not be used
	//					on objects that dont move.
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void UpdateObject ( CSceneObject* pObject );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// CKdTree():	Default Constructor
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CKdTree ();

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// CKdTree():	Copy Constructor
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CKdTree ( const CKdTree& ) {}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// operator=():	Assignment Operator
	//
	// Returns:		CKdTree&
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CKdTree& operator= ( const CKdTree& ) { return *this; }

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// ReturnObjInsert():	Takes in a SceneObject pointer (_pObject). This function inserts the given object inside the 
	//						return vector
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static void ReturnObjInsert ( CSceneObject* pObject );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// ReturnObjClear():	This function clears out the return vector.
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void ReturnObjClear ();

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// InsertObjInLeaf():	Takes in a LeafNode pointer and TraverseData pointer (_pLeaf, _pData). This function
	//						adds the object inside the TraverseData to the leafs object list and adds the leaf
	//						to the objects leaf list.
	//
	// Returns:		bool
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static bool InsertObjInLeaf ( CLeafNode* pLeaf, tTraverseData* pData );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// SphereLeafSplit():	Takes in an InternalNode pointer and TraverseData pointer (_pNode, _pData). This function
	//						splits the InternalNode based on the Sphere that is in the TraverseData.
	//
	// Returns:		unsigned int
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static unsigned int SphereLeafSplit ( CInternalNode* pNode, tTraverseData* pData );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// CapsuleLeafSplit():	Takes in an InternalNode pointer and TraverseData pointer (_pNode, _pData). This function
	//						splits the InternalNode based on the Capsule that is in the TraverseData.
	//
	// Returns:		unsigned int
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static unsigned int CapsuleLeafSplit ( CInternalNode* pNode, tTraverseData* pData );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// PointLeafSplit():	Takes in an InternalNode pointer and TraverseData pointer (_pNode, _pData). This function
	//						splits the InternalNode based on the Point that is in the TraverseData.
	//
	// Returns:		unsigned int
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static unsigned int PointLeafSplit ( CInternalNode* pNode, tTraverseData* pData );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// LineLeafSplit():	Takes in an InternalNode pointer and TraverseData pointer (_pNode, _pData). This function
	//						splits the InternalNode based on the Line that is in the TraverseData.
	//
	// Returns:		unsigned int
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static unsigned int LineLeafSplit ( CInternalNode* pNode, tTraverseData* pData );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// AABBLeafSplit():	Takes in an InternalNode pointer and TraverseData pointer (_pNode, _pData). This function
	//						splits the InternalNode based on the AABB that is in the TraverseData.
	//
	// Returns:		unsigned int
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static unsigned int AABBLeafSplit ( CInternalNode* pNode, tTraverseData* pData );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// BoxLeafSplit():	Takes in an InternalNode pointer and TraverseData pointer (_pNode, _pData). This function
	//						splits the InternalNode based on the Box that is in the TraverseData.
	//
	// Returns:		unsigned int
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static unsigned int BoxLeafSplit ( CInternalNode* pNode, tTraverseData* pData );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// FrustumLeafSplit():	Takes in an InternalNode pointer and TraverseData pointer (_pNode, _pData). This function
	//						splits the InternalNode based on the Frustums AABB that is in the TraverseData.
	//
	// Returns:		unsigned int
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static unsigned int FrustumLeafSplit ( CInternalNode* pNode, tTraverseData* pData);

	

public:
	static CKdTree* m_pMainTree;
	std::vector < CLeafNode* > debugLeafTest;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Init():	Takes in an AABB (_abBounds).  Creates the kd tree based on the passed 
	//			in bounbing box.
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static void Init ( const AABB& abBounds );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Shutdown():	Destories the kd tree and cleans up all memory
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static void Shutdown ();

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Update():	Updates all objects inside the kd tree so they are in the correct 
	//				leaves.
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static void Update ();

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// MasterObjInsert():	Takes in a SceneObject (pObject). This function add the object to the
	//			master list of object inside the kd tree. This may get removed because
	//			there does not need to be multiple lists of all objects.
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static void MasterObjInsert ( CSceneObject* pObjcet );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// MasterObjRemove():	Takes in a SceneObject (pObject). This function removes the object from
	//						the master list and any leaves it is overlapping. This function may 
	//						be removed or replaced with a different function because
	//						there does not need to be multiple lists of all objects.
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static void MasterObjRemove ( CSceneObject* pObject );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// GetNearObjects():	Takes in a CSceneObject pointer, and two flag paramaters (pPassedShape, emFlags,
	//						sReturnFlags), and a Output Vector Pramater (vReturnVector).
	//						This function goes through the kd tree and finds all object that
	//						match the ReturnFlags type ( which is a bit flag to the object types).
	//						It will return all found objects in the vReturnVector.
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static void GetNearObjects ( CSceneObject* pPassedShape, emPassedFlags emFlags, int sReturnFlags, std::vector < CSceneObject* >& vReturnVector, int sReturnBody = 0, int sReturnObject = 0 );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Traversal():	THIS IS A PRIVATE FUNCTION AND YOU SHOULD NOT CALL IT. This function traverses through the kd tree
	//				and fills out the necessary information.
	//
	// Returns:		unsigned int
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static unsigned int Traversal ( CTreeNode* pNode, tTraverseData* pData );

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Traverse():	THIS IS A PRIVATE FUNCTION AND YOU SHOULD NOT CALL IT. This function is the starting point for 
	//				traverseing through the tree
	//
	// Returns:		Void
	//
	// Mod. Name:
	// Mod. Date:
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void Traverse ( tTraverseData* pData );

	static void FlushKDTree( void );

	/////////////////////////////
	//  Accessors
	/////////////////////////////
	std::list < CLeafNode* >& GetLeaves () { return m_lsLeafs; }
	CTreeNode* GetTreeRoot () { return m_pTreeRoot; }

	/////////////////////////////
	//  Mutators
	/////////////////////////////
	void SetTreeRoot ( CTreeNode* pRoot ) { m_pTreeRoot = pRoot; }	
};


#endif